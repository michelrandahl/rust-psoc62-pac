# [doc = "Register `CTRL` reader"] pub type R = crate :: R < CTRL_SPEC > ; # [doc = "Register `CTRL` writer"] pub type W = crate :: W < CTRL_SPEC > ; # [doc = "Field `PWR_CTRL_VREF` reader - VREF buffer low power mode."] pub type PWR_CTRL_VREF_R = crate :: FieldReader < PWR_CTRL_VREF_A > ; # [doc = "VREF buffer low power mode.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum PWR_CTRL_VREF_A { # [doc = "0: full power (100 percent) (default), bypass cap, max clk_sar is 18MHz."] PWR_100 = 0 , # [doc = "1: 80 percent power"] PWR_80 = 1 , # [doc = "2: 60 percent power"] PWR_60 = 2 , # [doc = "3: 50 percent power"] PWR_50 = 3 , # [doc = "4: 40 percent power"] PWR_40 = 4 , # [doc = "5: 30 percent power"] PWR_30 = 5 , # [doc = "6: 20 percent power"] PWR_20 = 6 , # [doc = "7: 10 percent power"] PWR_10 = 7 , } impl From < PWR_CTRL_VREF_A > for u8 { # [inline (always)] fn from (variant : PWR_CTRL_VREF_A) -> Self { variant as _ } } impl crate :: FieldSpec for PWR_CTRL_VREF_A { type Ux = u8 ; } impl PWR_CTRL_VREF_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> PWR_CTRL_VREF_A { match self . bits { 0 => PWR_CTRL_VREF_A :: PWR_100 , 1 => PWR_CTRL_VREF_A :: PWR_80 , 2 => PWR_CTRL_VREF_A :: PWR_60 , 3 => PWR_CTRL_VREF_A :: PWR_50 , 4 => PWR_CTRL_VREF_A :: PWR_40 , 5 => PWR_CTRL_VREF_A :: PWR_30 , 6 => PWR_CTRL_VREF_A :: PWR_20 , 7 => PWR_CTRL_VREF_A :: PWR_10 , _ => unreachable ! () , } } # [doc = "full power (100 percent) (default), bypass cap, max clk_sar is 18MHz."] # [inline (always)] pub fn is_pwr_100 (& self) -> bool { * self == PWR_CTRL_VREF_A :: PWR_100 } # [doc = "80 percent power"] # [inline (always)] pub fn is_pwr_80 (& self) -> bool { * self == PWR_CTRL_VREF_A :: PWR_80 } # [doc = "60 percent power"] # [inline (always)] pub fn is_pwr_60 (& self) -> bool { * self == PWR_CTRL_VREF_A :: PWR_60 } # [doc = "50 percent power"] # [inline (always)] pub fn is_pwr_50 (& self) -> bool { * self == PWR_CTRL_VREF_A :: PWR_50 } # [doc = "40 percent power"] # [inline (always)] pub fn is_pwr_40 (& self) -> bool { * self == PWR_CTRL_VREF_A :: PWR_40 } # [doc = "30 percent power"] # [inline (always)] pub fn is_pwr_30 (& self) -> bool { * self == PWR_CTRL_VREF_A :: PWR_30 } # [doc = "20 percent power"] # [inline (always)] pub fn is_pwr_20 (& self) -> bool { * self == PWR_CTRL_VREF_A :: PWR_20 } # [doc = "10 percent power"] # [inline (always)] pub fn is_pwr_10 (& self) -> bool { * self == PWR_CTRL_VREF_A :: PWR_10 } } # [doc = "Field `PWR_CTRL_VREF` writer - VREF buffer low power mode."] pub type PWR_CTRL_VREF_W < 'a , REG > = crate :: FieldWriterSafe < 'a , REG , 3 , PWR_CTRL_VREF_A > ; impl < 'a , REG > PWR_CTRL_VREF_W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > , { # [doc = "full power (100 percent) (default), bypass cap, max clk_sar is 18MHz."] # [inline (always)] pub fn pwr_100 (self) -> & 'a mut crate :: W < REG > { self . variant (PWR_CTRL_VREF_A :: PWR_100) } # [doc = "80 percent power"] # [inline (always)] pub fn pwr_80 (self) -> & 'a mut crate :: W < REG > { self . variant (PWR_CTRL_VREF_A :: PWR_80) } # [doc = "60 percent power"] # [inline (always)] pub fn pwr_60 (self) -> & 'a mut crate :: W < REG > { self . variant (PWR_CTRL_VREF_A :: PWR_60) } # [doc = "50 percent power"] # [inline (always)] pub fn pwr_50 (self) -> & 'a mut crate :: W < REG > { self . variant (PWR_CTRL_VREF_A :: PWR_50) } # [doc = "40 percent power"] # [inline (always)] pub fn pwr_40 (self) -> & 'a mut crate :: W < REG > { self . variant (PWR_CTRL_VREF_A :: PWR_40) } # [doc = "30 percent power"] # [inline (always)] pub fn pwr_30 (self) -> & 'a mut crate :: W < REG > { self . variant (PWR_CTRL_VREF_A :: PWR_30) } # [doc = "20 percent power"] # [inline (always)] pub fn pwr_20 (self) -> & 'a mut crate :: W < REG > { self . variant (PWR_CTRL_VREF_A :: PWR_20) } # [doc = "10 percent power"] # [inline (always)] pub fn pwr_10 (self) -> & 'a mut crate :: W < REG > { self . variant (PWR_CTRL_VREF_A :: PWR_10) } } # [doc = "Field `VREF_SEL` reader - SARADC internal VREF selection."] pub type VREF_SEL_R = crate :: FieldReader < VREF_SEL_A > ; # [doc = "SARADC internal VREF selection.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum VREF_SEL_A { # [doc = "0: VREF0 from PRB (VREF buffer on)"] VREF0 = 0 , # [doc = "1: VREF1 from PRB (VREF buffer on)"] VREF1 = 1 , # [doc = "2: VREF2 from PRB (VREF buffer on)"] VREF2 = 2 , # [doc = "3: VREF from AROUTE (VREF buffer on)"] VREF_AROUTE = 3 , # [doc = "4: 1.024V from BandGap (VREF buffer on)"] VBGR = 4 , # [doc = "5: External precision Vref direct from a pin (low impedance path)."] VREF_EXT = 5 , # [doc = "6: Vdda/2 (VREF buffer on)"] VDDA_DIV_2 = 6 , # [doc = "7: Vdda."] VDDA = 7 , } impl From < VREF_SEL_A > for u8 { # [inline (always)] fn from (variant : VREF_SEL_A) -> Self { variant as _ } } impl crate :: FieldSpec for VREF_SEL_A { type Ux = u8 ; } impl VREF_SEL_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> VREF_SEL_A { match self . bits { 0 => VREF_SEL_A :: VREF0 , 1 => VREF_SEL_A :: VREF1 , 2 => VREF_SEL_A :: VREF2 , 3 => VREF_SEL_A :: VREF_AROUTE , 4 => VREF_SEL_A :: VBGR , 5 => VREF_SEL_A :: VREF_EXT , 6 => VREF_SEL_A :: VDDA_DIV_2 , 7 => VREF_SEL_A :: VDDA , _ => unreachable ! () , } } # [doc = "VREF0 from PRB (VREF buffer on)"] # [inline (always)] pub fn is_vref0 (& self) -> bool { * self == VREF_SEL_A :: VREF0 } # [doc = "VREF1 from PRB (VREF buffer on)"] # [inline (always)] pub fn is_vref1 (& self) -> bool { * self == VREF_SEL_A :: VREF1 } # [doc = "VREF2 from PRB (VREF buffer on)"] # [inline (always)] pub fn is_vref2 (& self) -> bool { * self == VREF_SEL_A :: VREF2 } # [doc = "VREF from AROUTE (VREF buffer on)"] # [inline (always)] pub fn is_vref_aroute (& self) -> bool { * self == VREF_SEL_A :: VREF_AROUTE } # [doc = "1.024V from BandGap (VREF buffer on)"] # [inline (always)] pub fn is_vbgr (& self) -> bool { * self == VREF_SEL_A :: VBGR } # [doc = "External precision Vref direct from a pin (low impedance path)."] # [inline (always)] pub fn is_vref_ext (& self) -> bool { * self == VREF_SEL_A :: VREF_EXT } # [doc = "Vdda/2 (VREF buffer on)"] # [inline (always)] pub fn is_vdda_div_2 (& self) -> bool { * self == VREF_SEL_A :: VDDA_DIV_2 } # [doc = "Vdda."] # [inline (always)] pub fn is_vdda (& self) -> bool { * self == VREF_SEL_A :: VDDA } } # [doc = "Field `VREF_SEL` writer - SARADC internal VREF selection."] pub type VREF_SEL_W < 'a , REG > = crate :: FieldWriterSafe < 'a , REG , 3 , VREF_SEL_A > ; impl < 'a , REG > VREF_SEL_W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > , { # [doc = "VREF0 from PRB (VREF buffer on)"] # [inline (always)] pub fn vref0 (self) -> & 'a mut crate :: W < REG > { self . variant (VREF_SEL_A :: VREF0) } # [doc = "VREF1 from PRB (VREF buffer on)"] # [inline (always)] pub fn vref1 (self) -> & 'a mut crate :: W < REG > { self . variant (VREF_SEL_A :: VREF1) } # [doc = "VREF2 from PRB (VREF buffer on)"] # [inline (always)] pub fn vref2 (self) -> & 'a mut crate :: W < REG > { self . variant (VREF_SEL_A :: VREF2) } # [doc = "VREF from AROUTE (VREF buffer on)"] # [inline (always)] pub fn vref_aroute (self) -> & 'a mut crate :: W < REG > { self . variant (VREF_SEL_A :: VREF_AROUTE) } # [doc = "1.024V from BandGap (VREF buffer on)"] # [inline (always)] pub fn vbgr (self) -> & 'a mut crate :: W < REG > { self . variant (VREF_SEL_A :: VBGR) } # [doc = "External precision Vref direct from a pin (low impedance path)."] # [inline (always)] pub fn vref_ext (self) -> & 'a mut crate :: W < REG > { self . variant (VREF_SEL_A :: VREF_EXT) } # [doc = "Vdda/2 (VREF buffer on)"] # [inline (always)] pub fn vdda_div_2 (self) -> & 'a mut crate :: W < REG > { self . variant (VREF_SEL_A :: VDDA_DIV_2) } # [doc = "Vdda."] # [inline (always)] pub fn vdda (self) -> & 'a mut crate :: W < REG > { self . variant (VREF_SEL_A :: VDDA) } } # [doc = "Field `VREF_BYP_CAP_EN` reader - VREF bypass cap enable for when VREF buffer is on"] pub type VREF_BYP_CAP_EN_R = crate :: BitReader ; # [doc = "Field `VREF_BYP_CAP_EN` writer - VREF bypass cap enable for when VREF buffer is on"] pub type VREF_BYP_CAP_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `NEG_SEL` reader - SARADC internal NEG selection for Single ended conversion"] pub type NEG_SEL_R = crate :: FieldReader < NEG_SEL_A > ; # [doc = "SARADC internal NEG selection for Single ended conversion\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum NEG_SEL_A { # [doc = "0: NEG input of SARADC is connected to 'vssa_kelvin', gives more precision around zero. Note this opens both SARADC internal switches, therefore use this value to insert a break-before-make cycle on those switches when SWITCH_DISABLE is high."] VSSA_KELVIN = 0 , # [doc = "1: NEG input of SARADC is connected to VSSA in AROUTE close to the SARADC"] ART_VSSA = 1 , # [doc = "2: NEG input of SARADC is connected to P1 pin of SARMUX"] P1 = 2 , # [doc = "3: NEG input of SARADC is connected to P3 pin of SARMUX"] P3 = 3 , # [doc = "4: NEG input of SARADC is connected to P5 pin of SARMUX"] P5 = 4 , # [doc = "5: NEG input of SARADC is connected to P7 pin of SARMUX"] P7 = 5 , # [doc = "6: NEG input of SARADC is connected to an ACORE in AROUTE"] ACORE = 6 , # [doc = "7: NEG input of SARADC is shorted with VREF input of SARADC."] VREF = 7 , } impl From < NEG_SEL_A > for u8 { # [inline (always)] fn from (variant : NEG_SEL_A) -> Self { variant as _ } } impl crate :: FieldSpec for NEG_SEL_A { type Ux = u8 ; } impl NEG_SEL_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> NEG_SEL_A { match self . bits { 0 => NEG_SEL_A :: VSSA_KELVIN , 1 => NEG_SEL_A :: ART_VSSA , 2 => NEG_SEL_A :: P1 , 3 => NEG_SEL_A :: P3 , 4 => NEG_SEL_A :: P5 , 5 => NEG_SEL_A :: P7 , 6 => NEG_SEL_A :: ACORE , 7 => NEG_SEL_A :: VREF , _ => unreachable ! () , } } # [doc = "NEG input of SARADC is connected to 'vssa_kelvin', gives more precision around zero. Note this opens both SARADC internal switches, therefore use this value to insert a break-before-make cycle on those switches when SWITCH_DISABLE is high."] # [inline (always)] pub fn is_vssa_kelvin (& self) -> bool { * self == NEG_SEL_A :: VSSA_KELVIN } # [doc = "NEG input of SARADC is connected to VSSA in AROUTE close to the SARADC"] # [inline (always)] pub fn is_art_vssa (& self) -> bool { * self == NEG_SEL_A :: ART_VSSA } # [doc = "NEG input of SARADC is connected to P1 pin of SARMUX"] # [inline (always)] pub fn is_p1 (& self) -> bool { * self == NEG_SEL_A :: P1 } # [doc = "NEG input of SARADC is connected to P3 pin of SARMUX"] # [inline (always)] pub fn is_p3 (& self) -> bool { * self == NEG_SEL_A :: P3 } # [doc = "NEG input of SARADC is connected to P5 pin of SARMUX"] # [inline (always)] pub fn is_p5 (& self) -> bool { * self == NEG_SEL_A :: P5 } # [doc = "NEG input of SARADC is connected to P7 pin of SARMUX"] # [inline (always)] pub fn is_p7 (& self) -> bool { * self == NEG_SEL_A :: P7 } # [doc = "NEG input of SARADC is connected to an ACORE in AROUTE"] # [inline (always)] pub fn is_acore (& self) -> bool { * self == NEG_SEL_A :: ACORE } # [doc = "NEG input of SARADC is shorted with VREF input of SARADC."] # [inline (always)] pub fn is_vref (& self) -> bool { * self == NEG_SEL_A :: VREF } } # [doc = "Field `NEG_SEL` writer - SARADC internal NEG selection for Single ended conversion"] pub type NEG_SEL_W < 'a , REG > = crate :: FieldWriterSafe < 'a , REG , 3 , NEG_SEL_A > ; impl < 'a , REG > NEG_SEL_W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > , { # [doc = "NEG input of SARADC is connected to 'vssa_kelvin', gives more precision around zero. Note this opens both SARADC internal switches, therefore use this value to insert a break-before-make cycle on those switches when SWITCH_DISABLE is high."] # [inline (always)] pub fn vssa_kelvin (self) -> & 'a mut crate :: W < REG > { self . variant (NEG_SEL_A :: VSSA_KELVIN) } # [doc = "NEG input of SARADC is connected to VSSA in AROUTE close to the SARADC"] # [inline (always)] pub fn art_vssa (self) -> & 'a mut crate :: W < REG > { self . variant (NEG_SEL_A :: ART_VSSA) } # [doc = "NEG input of SARADC is connected to P1 pin of SARMUX"] # [inline (always)] pub fn p1 (self) -> & 'a mut crate :: W < REG > { self . variant (NEG_SEL_A :: P1) } # [doc = "NEG input of SARADC is connected to P3 pin of SARMUX"] # [inline (always)] pub fn p3 (self) -> & 'a mut crate :: W < REG > { self . variant (NEG_SEL_A :: P3) } # [doc = "NEG input of SARADC is connected to P5 pin of SARMUX"] # [inline (always)] pub fn p5 (self) -> & 'a mut crate :: W < REG > { self . variant (NEG_SEL_A :: P5) } # [doc = "NEG input of SARADC is connected to P7 pin of SARMUX"] # [inline (always)] pub fn p7 (self) -> & 'a mut crate :: W < REG > { self . variant (NEG_SEL_A :: P7) } # [doc = "NEG input of SARADC is connected to an ACORE in AROUTE"] # [inline (always)] pub fn acore (self) -> & 'a mut crate :: W < REG > { self . variant (NEG_SEL_A :: ACORE) } # [doc = "NEG input of SARADC is shorted with VREF input of SARADC."] # [inline (always)] pub fn vref (self) -> & 'a mut crate :: W < REG > { self . variant (NEG_SEL_A :: VREF) } } # [doc = "Field `SAR_HW_CTRL_NEGVREF` reader - Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for VREF to NEG switch."] pub type SAR_HW_CTRL_NEGVREF_R = crate :: BitReader ; # [doc = "Field `SAR_HW_CTRL_NEGVREF` writer - Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for VREF to NEG switch."] pub type SAR_HW_CTRL_NEGVREF_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `COMP_DLY` reader - Set the comparator latch delay in accordance with SAR conversion rate"] pub type COMP_DLY_R = crate :: FieldReader < COMP_DLY_A > ; # [doc = "Set the comparator latch delay in accordance with SAR conversion rate\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum COMP_DLY_A { # [doc = "0: 2.5ns delay, use this for 2.5Msps"] D2P5 = 0 , # [doc = "1: 4.0ns delay, use this for 2.0Msps"] D4 = 1 , # [doc = "2: 10ns delay, use this for 1.5Msps"] D10 = 2 , # [doc = "3: 12ns delay, use this for 1.0Msps or less"] D12 = 3 , } impl From < COMP_DLY_A > for u8 { # [inline (always)] fn from (variant : COMP_DLY_A) -> Self { variant as _ } } impl crate :: FieldSpec for COMP_DLY_A { type Ux = u8 ; } impl COMP_DLY_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> COMP_DLY_A { match self . bits { 0 => COMP_DLY_A :: D2P5 , 1 => COMP_DLY_A :: D4 , 2 => COMP_DLY_A :: D10 , 3 => COMP_DLY_A :: D12 , _ => unreachable ! () , } } # [doc = "2.5ns delay, use this for 2.5Msps"] # [inline (always)] pub fn is_d2p5 (& self) -> bool { * self == COMP_DLY_A :: D2P5 } # [doc = "4.0ns delay, use this for 2.0Msps"] # [inline (always)] pub fn is_d4 (& self) -> bool { * self == COMP_DLY_A :: D4 } # [doc = "10ns delay, use this for 1.5Msps"] # [inline (always)] pub fn is_d10 (& self) -> bool { * self == COMP_DLY_A :: D10 } # [doc = "12ns delay, use this for 1.0Msps or less"] # [inline (always)] pub fn is_d12 (& self) -> bool { * self == COMP_DLY_A :: D12 } } # [doc = "Field `COMP_DLY` writer - Set the comparator latch delay in accordance with SAR conversion rate"] pub type COMP_DLY_W < 'a , REG > = crate :: FieldWriterSafe < 'a , REG , 2 , COMP_DLY_A > ; impl < 'a , REG > COMP_DLY_W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > , { # [doc = "2.5ns delay, use this for 2.5Msps"] # [inline (always)] pub fn d2p5 (self) -> & 'a mut crate :: W < REG > { self . variant (COMP_DLY_A :: D2P5) } # [doc = "4.0ns delay, use this for 2.0Msps"] # [inline (always)] pub fn d4 (self) -> & 'a mut crate :: W < REG > { self . variant (COMP_DLY_A :: D4) } # [doc = "10ns delay, use this for 1.5Msps"] # [inline (always)] pub fn d10 (self) -> & 'a mut crate :: W < REG > { self . variant (COMP_DLY_A :: D10) } # [doc = "12ns delay, use this for 1.0Msps or less"] # [inline (always)] pub fn d12 (self) -> & 'a mut crate :: W < REG > { self . variant (COMP_DLY_A :: D12) } } # [doc = "Field `SPARE` reader - Spare controls, not yet designated, for late changes done with an ECO"] pub type SPARE_R = crate :: FieldReader ; # [doc = "Field `SPARE` writer - Spare controls, not yet designated, for late changes done with an ECO"] pub type SPARE_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; # [doc = "Field `BOOSTPUMP_EN` reader - deprecated"] pub type BOOSTPUMP_EN_R = crate :: BitReader ; # [doc = "Field `BOOSTPUMP_EN` writer - deprecated"] pub type BOOSTPUMP_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `REFBUF_EN` reader - For normal ADC operation this bit must be set, for all reference choices - internal, external or vdda based reference. Setting this bit is critical to proper function of switches inside SARREF block."] pub type REFBUF_EN_R = crate :: BitReader ; # [doc = "Field `REFBUF_EN` writer - For normal ADC operation this bit must be set, for all reference choices - internal, external or vdda based reference. Setting this bit is critical to proper function of switches inside SARREF block."] pub type REFBUF_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `COMP_PWR` reader - Comparator power mode. (Sample rate TBD)"] pub type COMP_PWR_R = crate :: FieldReader < COMP_PWR_A > ; # [doc = "Comparator power mode. (Sample rate TBD)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum COMP_PWR_A { # [doc = "0: Power = 100 percent, use this for >2000Ksps"] P100 = 0 , # [doc = "1: Power = 80 percent, use this for 1500-2000Ksps"] P80 = 1 , # [doc = "2: Power = 60 percent, use this for 1000-1500Ksps"] P60 = 2 , # [doc = "3: Power = 50 percent, use this for 500-1000Ksps"] P50 = 3 , # [doc = "4: Power = 40 percent, use this for 250-500Ksps"] P40 = 4 , # [doc = "5: Power = 30 percent, use this for 100-250Ksps"] P30 = 5 , # [doc = "6: Power = 20 percent, use this for 100-250Ksps (TBD!)"] P20 = 6 , # [doc = "7: Power = 10 percent, use this for &lt;100Ksps"] P10 = 7 , } impl From < COMP_PWR_A > for u8 { # [inline (always)] fn from (variant : COMP_PWR_A) -> Self { variant as _ } } impl crate :: FieldSpec for COMP_PWR_A { type Ux = u8 ; } impl COMP_PWR_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> COMP_PWR_A { match self . bits { 0 => COMP_PWR_A :: P100 , 1 => COMP_PWR_A :: P80 , 2 => COMP_PWR_A :: P60 , 3 => COMP_PWR_A :: P50 , 4 => COMP_PWR_A :: P40 , 5 => COMP_PWR_A :: P30 , 6 => COMP_PWR_A :: P20 , 7 => COMP_PWR_A :: P10 , _ => unreachable ! () , } } # [doc = "Power = 100 percent, use this for >2000Ksps"] # [inline (always)] pub fn is_p100 (& self) -> bool { * self == COMP_PWR_A :: P100 } # [doc = "Power = 80 percent, use this for 1500-2000Ksps"] # [inline (always)] pub fn is_p80 (& self) -> bool { * self == COMP_PWR_A :: P80 } # [doc = "Power = 60 percent, use this for 1000-1500Ksps"] # [inline (always)] pub fn is_p60 (& self) -> bool { * self == COMP_PWR_A :: P60 } # [doc = "Power = 50 percent, use this for 500-1000Ksps"] # [inline (always)] pub fn is_p50 (& self) -> bool { * self == COMP_PWR_A :: P50 } # [doc = "Power = 40 percent, use this for 250-500Ksps"] # [inline (always)] pub fn is_p40 (& self) -> bool { * self == COMP_PWR_A :: P40 } # [doc = "Power = 30 percent, use this for 100-250Ksps"] # [inline (always)] pub fn is_p30 (& self) -> bool { * self == COMP_PWR_A :: P30 } # [doc = "Power = 20 percent, use this for 100-250Ksps (TBD!)"] # [inline (always)] pub fn is_p20 (& self) -> bool { * self == COMP_PWR_A :: P20 } # [doc = "Power = 10 percent, use this for &lt;100Ksps"] # [inline (always)] pub fn is_p10 (& self) -> bool { * self == COMP_PWR_A :: P10 } } # [doc = "Field `COMP_PWR` writer - Comparator power mode. (Sample rate TBD)"] pub type COMP_PWR_W < 'a , REG > = crate :: FieldWriterSafe < 'a , REG , 3 , COMP_PWR_A > ; impl < 'a , REG > COMP_PWR_W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > , { # [doc = "Power = 100 percent, use this for >2000Ksps"] # [inline (always)] pub fn p100 (self) -> & 'a mut crate :: W < REG > { self . variant (COMP_PWR_A :: P100) } # [doc = "Power = 80 percent, use this for 1500-2000Ksps"] # [inline (always)] pub fn p80 (self) -> & 'a mut crate :: W < REG > { self . variant (COMP_PWR_A :: P80) } # [doc = "Power = 60 percent, use this for 1000-1500Ksps"] # [inline (always)] pub fn p60 (self) -> & 'a mut crate :: W < REG > { self . variant (COMP_PWR_A :: P60) } # [doc = "Power = 50 percent, use this for 500-1000Ksps"] # [inline (always)] pub fn p50 (self) -> & 'a mut crate :: W < REG > { self . variant (COMP_PWR_A :: P50) } # [doc = "Power = 40 percent, use this for 250-500Ksps"] # [inline (always)] pub fn p40 (self) -> & 'a mut crate :: W < REG > { self . variant (COMP_PWR_A :: P40) } # [doc = "Power = 30 percent, use this for 100-250Ksps"] # [inline (always)] pub fn p30 (self) -> & 'a mut crate :: W < REG > { self . variant (COMP_PWR_A :: P30) } # [doc = "Power = 20 percent, use this for 100-250Ksps (TBD!)"] # [inline (always)] pub fn p20 (self) -> & 'a mut crate :: W < REG > { self . variant (COMP_PWR_A :: P20) } # [doc = "Power = 10 percent, use this for &lt;100Ksps"] # [inline (always)] pub fn p10 (self) -> & 'a mut crate :: W < REG > { self . variant (COMP_PWR_A :: P10) } } # [doc = "Field `DEEPSLEEP_ON` reader - - 0: SARMUX IP disabled off during DeepSleep power mode - 1: SARMUX IP remains enabled during DeepSleep power mode (if ENABLED=1)"] pub type DEEPSLEEP_ON_R = crate :: BitReader ; # [doc = "Field `DEEPSLEEP_ON` writer - - 0: SARMUX IP disabled off during DeepSleep power mode - 1: SARMUX IP remains enabled during DeepSleep power mode (if ENABLED=1)"] pub type DEEPSLEEP_ON_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `DSI_SYNC_CONFIG` reader - - 0: bypass clock domain synchronization of the DSI config signals. - 1: synchronize the DSI config signals to peripheral clock domain."] pub type DSI_SYNC_CONFIG_R = crate :: BitReader ; # [doc = "Field `DSI_SYNC_CONFIG` writer - - 0: bypass clock domain synchronization of the DSI config signals. - 1: synchronize the DSI config signals to peripheral clock domain."] pub type DSI_SYNC_CONFIG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `DSI_MODE` reader - SAR sequencer takes configuration from DSI signals (note this also has the same effect as SWITCH_DISABLE==1) - 0: Normal mode, SAR sequencer operates according to CHAN_EN enables and CHAN_CONFIG channel configurations - 1: CHAN_EN, INJ_START_EN and channel configurations in CHAN_CONFIG and INJ_CHAN_CONFIG are ignored"] pub type DSI_MODE_R = crate :: BitReader ; # [doc = "Field `DSI_MODE` writer - SAR sequencer takes configuration from DSI signals (note this also has the same effect as SWITCH_DISABLE==1) - 0: Normal mode, SAR sequencer operates according to CHAN_EN enables and CHAN_CONFIG channel configurations - 1: CHAN_EN, INJ_START_EN and channel configurations in CHAN_CONFIG and INJ_CHAN_CONFIG are ignored"] pub type DSI_MODE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `SWITCH_DISABLE` reader - Disable SAR sequencer from enabling routing switches (note DSI and firmware can always close switches independent of this control) - 0: Normal mode, SAR sequencer changes switches according to pin address in channel configurations - 1: Switches disabled, SAR sequencer does not enable any switches, it is the responsibility of the firmware or UDBs (through DSI) to set the switches to route the signal to be converted through the SARMUX"] pub type SWITCH_DISABLE_R = crate :: BitReader ; # [doc = "Field `SWITCH_DISABLE` writer - Disable SAR sequencer from enabling routing switches (note DSI and firmware can always close switches independent of this control) - 0: Normal mode, SAR sequencer changes switches according to pin address in channel configurations - 1: Switches disabled, SAR sequencer does not enable any switches, it is the responsibility of the firmware or UDBs (through DSI) to set the switches to route the signal to be converted through the SARMUX"] pub type SWITCH_DISABLE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `ENABLED` reader - - 0: SAR IP disabled (put analog in power down and stop clocks), also can clear FW_TRIGGER and INJ_START_EN (if not tailgating) on write. - 1: SAR IP enabled."] pub type ENABLED_R = crate :: BitReader ; # [doc = "Field `ENABLED` writer - - 0: SAR IP disabled (put analog in power down and stop clocks), also can clear FW_TRIGGER and INJ_START_EN (if not tailgating) on write. - 1: SAR IP enabled."] pub type ENABLED_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bits 0:2 - VREF buffer low power mode."] # [inline (always)] pub fn pwr_ctrl_vref (& self) -> PWR_CTRL_VREF_R { PWR_CTRL_VREF_R :: new ((self . bits & 7) as u8) } # [doc = "Bits 4:6 - SARADC internal VREF selection."] # [inline (always)] pub fn vref_sel (& self) -> VREF_SEL_R { VREF_SEL_R :: new (((self . bits >> 4) & 7) as u8) } # [doc = "Bit 7 - VREF bypass cap enable for when VREF buffer is on"] # [inline (always)] pub fn vref_byp_cap_en (& self) -> VREF_BYP_CAP_EN_R { VREF_BYP_CAP_EN_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bits 9:11 - SARADC internal NEG selection for Single ended conversion"] # [inline (always)] pub fn neg_sel (& self) -> NEG_SEL_R { NEG_SEL_R :: new (((self . bits >> 9) & 7) as u8) } # [doc = "Bit 13 - Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for VREF to NEG switch."] # [inline (always)] pub fn sar_hw_ctrl_negvref (& self) -> SAR_HW_CTRL_NEGVREF_R { SAR_HW_CTRL_NEGVREF_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bits 14:15 - Set the comparator latch delay in accordance with SAR conversion rate"] # [inline (always)] pub fn comp_dly (& self) -> COMP_DLY_R { COMP_DLY_R :: new (((self . bits >> 14) & 3) as u8) } # [doc = "Bits 16:19 - Spare controls, not yet designated, for late changes done with an ECO"] # [inline (always)] pub fn spare (& self) -> SPARE_R { SPARE_R :: new (((self . bits >> 16) & 0x0f) as u8) } # [doc = "Bit 20 - deprecated"] # [inline (always)] pub fn boostpump_en (& self) -> BOOSTPUMP_EN_R { BOOSTPUMP_EN_R :: new (((self . bits >> 20) & 1) != 0) } # [doc = "Bit 21 - For normal ADC operation this bit must be set, for all reference choices - internal, external or vdda based reference. Setting this bit is critical to proper function of switches inside SARREF block."] # [inline (always)] pub fn refbuf_en (& self) -> REFBUF_EN_R { REFBUF_EN_R :: new (((self . bits >> 21) & 1) != 0) } # [doc = "Bits 24:26 - Comparator power mode. (Sample rate TBD)"] # [inline (always)] pub fn comp_pwr (& self) -> COMP_PWR_R { COMP_PWR_R :: new (((self . bits >> 24) & 7) as u8) } # [doc = "Bit 27 - - 0: SARMUX IP disabled off during DeepSleep power mode - 1: SARMUX IP remains enabled during DeepSleep power mode (if ENABLED=1)"] # [inline (always)] pub fn deepsleep_on (& self) -> DEEPSLEEP_ON_R { DEEPSLEEP_ON_R :: new (((self . bits >> 27) & 1) != 0) } # [doc = "Bit 28 - - 0: bypass clock domain synchronization of the DSI config signals. - 1: synchronize the DSI config signals to peripheral clock domain."] # [inline (always)] pub fn dsi_sync_config (& self) -> DSI_SYNC_CONFIG_R { DSI_SYNC_CONFIG_R :: new (((self . bits >> 28) & 1) != 0) } # [doc = "Bit 29 - SAR sequencer takes configuration from DSI signals (note this also has the same effect as SWITCH_DISABLE==1) - 0: Normal mode, SAR sequencer operates according to CHAN_EN enables and CHAN_CONFIG channel configurations - 1: CHAN_EN, INJ_START_EN and channel configurations in CHAN_CONFIG and INJ_CHAN_CONFIG are ignored"] # [inline (always)] pub fn dsi_mode (& self) -> DSI_MODE_R { DSI_MODE_R :: new (((self . bits >> 29) & 1) != 0) } # [doc = "Bit 30 - Disable SAR sequencer from enabling routing switches (note DSI and firmware can always close switches independent of this control) - 0: Normal mode, SAR sequencer changes switches according to pin address in channel configurations - 1: Switches disabled, SAR sequencer does not enable any switches, it is the responsibility of the firmware or UDBs (through DSI) to set the switches to route the signal to be converted through the SARMUX"] # [inline (always)] pub fn switch_disable (& self) -> SWITCH_DISABLE_R { SWITCH_DISABLE_R :: new (((self . bits >> 30) & 1) != 0) } # [doc = "Bit 31 - - 0: SAR IP disabled (put analog in power down and stop clocks), also can clear FW_TRIGGER and INJ_START_EN (if not tailgating) on write. - 1: SAR IP enabled."] # [inline (always)] pub fn enabled (& self) -> ENABLED_R { ENABLED_R :: new (((self . bits >> 31) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - VREF buffer low power mode."] # [inline (always)] # [must_use] pub fn pwr_ctrl_vref (& mut self) -> PWR_CTRL_VREF_W < CTRL_SPEC > { PWR_CTRL_VREF_W :: new (self , 0) } # [doc = "Bits 4:6 - SARADC internal VREF selection."] # [inline (always)] # [must_use] pub fn vref_sel (& mut self) -> VREF_SEL_W < CTRL_SPEC > { VREF_SEL_W :: new (self , 4) } # [doc = "Bit 7 - VREF bypass cap enable for when VREF buffer is on"] # [inline (always)] # [must_use] pub fn vref_byp_cap_en (& mut self) -> VREF_BYP_CAP_EN_W < CTRL_SPEC > { VREF_BYP_CAP_EN_W :: new (self , 7) } # [doc = "Bits 9:11 - SARADC internal NEG selection for Single ended conversion"] # [inline (always)] # [must_use] pub fn neg_sel (& mut self) -> NEG_SEL_W < CTRL_SPEC > { NEG_SEL_W :: new (self , 9) } # [doc = "Bit 13 - Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for VREF to NEG switch."] # [inline (always)] # [must_use] pub fn sar_hw_ctrl_negvref (& mut self) -> SAR_HW_CTRL_NEGVREF_W < CTRL_SPEC > { SAR_HW_CTRL_NEGVREF_W :: new (self , 13) } # [doc = "Bits 14:15 - Set the comparator latch delay in accordance with SAR conversion rate"] # [inline (always)] # [must_use] pub fn comp_dly (& mut self) -> COMP_DLY_W < CTRL_SPEC > { COMP_DLY_W :: new (self , 14) } # [doc = "Bits 16:19 - Spare controls, not yet designated, for late changes done with an ECO"] # [inline (always)] # [must_use] pub fn spare (& mut self) -> SPARE_W < CTRL_SPEC > { SPARE_W :: new (self , 16) } # [doc = "Bit 20 - deprecated"] # [inline (always)] # [must_use] pub fn boostpump_en (& mut self) -> BOOSTPUMP_EN_W < CTRL_SPEC > { BOOSTPUMP_EN_W :: new (self , 20) } # [doc = "Bit 21 - For normal ADC operation this bit must be set, for all reference choices - internal, external or vdda based reference. Setting this bit is critical to proper function of switches inside SARREF block."] # [inline (always)] # [must_use] pub fn refbuf_en (& mut self) -> REFBUF_EN_W < CTRL_SPEC > { REFBUF_EN_W :: new (self , 21) } # [doc = "Bits 24:26 - Comparator power mode. (Sample rate TBD)"] # [inline (always)] # [must_use] pub fn comp_pwr (& mut self) -> COMP_PWR_W < CTRL_SPEC > { COMP_PWR_W :: new (self , 24) } # [doc = "Bit 27 - - 0: SARMUX IP disabled off during DeepSleep power mode - 1: SARMUX IP remains enabled during DeepSleep power mode (if ENABLED=1)"] # [inline (always)] # [must_use] pub fn deepsleep_on (& mut self) -> DEEPSLEEP_ON_W < CTRL_SPEC > { DEEPSLEEP_ON_W :: new (self , 27) } # [doc = "Bit 28 - - 0: bypass clock domain synchronization of the DSI config signals. - 1: synchronize the DSI config signals to peripheral clock domain."] # [inline (always)] # [must_use] pub fn dsi_sync_config (& mut self) -> DSI_SYNC_CONFIG_W < CTRL_SPEC > { DSI_SYNC_CONFIG_W :: new (self , 28) } # [doc = "Bit 29 - SAR sequencer takes configuration from DSI signals (note this also has the same effect as SWITCH_DISABLE==1) - 0: Normal mode, SAR sequencer operates according to CHAN_EN enables and CHAN_CONFIG channel configurations - 1: CHAN_EN, INJ_START_EN and channel configurations in CHAN_CONFIG and INJ_CHAN_CONFIG are ignored"] # [inline (always)] # [must_use] pub fn dsi_mode (& mut self) -> DSI_MODE_W < CTRL_SPEC > { DSI_MODE_W :: new (self , 29) } # [doc = "Bit 30 - Disable SAR sequencer from enabling routing switches (note DSI and firmware can always close switches independent of this control) - 0: Normal mode, SAR sequencer changes switches according to pin address in channel configurations - 1: Switches disabled, SAR sequencer does not enable any switches, it is the responsibility of the firmware or UDBs (through DSI) to set the switches to route the signal to be converted through the SARMUX"] # [inline (always)] # [must_use] pub fn switch_disable (& mut self) -> SWITCH_DISABLE_W < CTRL_SPEC > { SWITCH_DISABLE_W :: new (self , 30) } # [doc = "Bit 31 - - 0: SAR IP disabled (put analog in power down and stop clocks), also can clear FW_TRIGGER and INJ_START_EN (if not tailgating) on write. - 1: SAR IP enabled."] # [inline (always)] # [must_use] pub fn enabled (& mut self) -> ENABLED_W < CTRL_SPEC > { ENABLED_W :: new (self , 31) } # [doc = r" Writes raw bits to the register."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"] # [inline (always)] pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Analog control register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`ctrl::R`](R) reader structure"] impl crate :: Readable for CTRL_SPEC { } # [doc = "`write(|w| ..)` method takes [`ctrl::W`](W) writer structure"] impl crate :: Writable for CTRL_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRL to value 0x1000_0000"] impl crate :: Resettable for CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0x1000_0000 ; }